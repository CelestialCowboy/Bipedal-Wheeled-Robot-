/*********************************************************************
 *  Self-Balancing Robot – SimpleFOC + MPU6050 + AS5600 (via I2C mux)
 *  ---------------------------------------------------------------
 *  • Kalman-filtered pitch
 *  • PID balance control
 *  • Motor-velocity balance compensation
 *  • Fall-detection + 5 s upright-hold recovery
 *********************************************************************/

#include <SimpleFOC.h>
#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>
#include <Wire.h>

/* -------------------- 1. CONSTANTS & TUNING -------------------- */
constexpr uint8_t PCA9548A_ADDR = 0x70;

constexpr float TARGET_PITCH      = -3.0f;   // Desired pitch (deg)
constexpr float DEAD_ZONE         = 0.05f;  // Pitch error dead-zone
constexpr float FALL_THRESHOLD    = 65.0f;  // deg → FALLEN
constexpr float UPRIGHT_MIN       = -10.0f;
constexpr float UPRIGHT_MAX       =  10.0f;
constexpr unsigned long RECOVERY_TIME = 5000; // ms

// PID for balancing
PIDController pid_balance{0.62f, 0.35f, 0.01f, 10000.0f, 20.0f};

// Motor-balance compensation
constexpr float BALANCE_KP               = 0.25f;
constexpr float BALANCE_KI               = 0.02f;
constexpr float MAX_BALANCE_COMPENSATION = 4.0f;

/* -------------------- 2. SIMPLE KALMAN FILTER ------------------- */
struct SimpleKalman {
  float Q_angle   = 0.001f;
  float Q_bias    = 0.003f;
  float R_measure = 0.03f;

  float angle = 0.0f;
  float bias  = 0.0f;
  float P[2][2]{};

  float getAngle(float newAngle, float newRate, float dt) {
    // ---- prediction ----
    const float rate = newRate - bias;
    angle += dt * rate;

    P[0][0] += dt * (dt * P[1][1] - P[0][1] - P[1][0] + Q_angle);
    P[0][1] -= dt * P[1][1];
    P[1][0] -= dt * P[1][1];
    P[1][1] += Q_bias * dt;

    // ---- update ----
    const float y = newAngle - angle;          // innovation
    const float S = P[0][0] + R_measure;       // innovation covariance

    const float K0 = P[0][0] / S;               // Kalman gains
    const float K1 = P[1][0] / S;

    angle += K0 * y;
    bias  += K1 * y;

    const float P00_temp = P[0][0];
    const float P01_temp = P[0][1];

    P[0][0] -= K0 * P00_temp;
    P[0][1] -= K0 * P01_temp;
    P[1][0] -= K1 * P00_temp;
    P[1][1] -= K1 * P01_temp;

    return angle;
  }
};
SimpleKalman kalman;

/* -------------------- 3. HARDWARE PINS -------------------------- */
struct DriverPins {
  uint8_t inhA, inhB, inhC, enGate, pwm, oc, ocAdj;
};

constexpr DriverPins drv1{16, 17, 12, 27, 26, 36, 25};
constexpr DriverPins drv2{32, 33, 19, 13, 18, 34, 23};

/* -------------------- 4. GLOBAL OBJECTS ------------------------- */
Adafruit_MPU6050 mpu;

BLDCMotor   motor1{7, 0.1f, 400};
BLDCDriver3PWM driver1{drv1.inhA, drv1.inhB, drv1.inhC, drv1.enGate};

BLDCMotor   motor2{7, 0.1f, 400};
BLDCDriver3PWM driver2{drv2.inhA, drv2.inhB, drv2.inhC, drv2.enGate};

MagneticSensorI2C encoder1{0x36, 12, 0x0E, 4};
MagneticSensorI2C encoder2{0x36, 12, 0x0E, 4};

Commander command{Serial};

/* -------------------- 5. STATE MACHINE -------------------------- */
enum class RobotState { NORMAL, FALLEN, RECOVERY };
RobotState robotState = RobotState::NORMAL;
unsigned long uprightStartTime = 0;

/* -------------------- 6. VELOCITY TRACKING ---------------------- */
float motor1_vel = 0.0f, motor2_vel = 0.0f;
float last_m1_angle = 0.0f, last_m2_angle = 0.0f;
unsigned long last_vel_time = 0;

/* -------------------- 7. BALANCE COMPENSATION ------------------- */
float balance_comp = 0.0f;
float vel_error_integral = 0.0f;

/* -------------------- 8. HELPERS -------------------------------- */
static inline void selectChannel(uint8_t ch) {
  Wire.beginTransmission(PCA9548A_ADDR);
  Wire.write(1 << ch);
  if (Wire.endTransmission() != 0) {
    Serial.println(F("I2C mux error!"));
  }
}

static inline void initMotor(BLDCMotor& m, BLDCDriver3PWM& d,
                             MagneticSensorI2C& enc, uint8_t chan) {
  selectChannel(chan);
  enc.init();
  m.linkSensor(&enc);
  d.voltage_power_supply = 24.0f;
  d.init();
  m.linkDriver(&d);

  m.voltage_sensor_align = 1.0f;
  m.torque_controller    = TorqueControlType::voltage;
  m.controller           = MotionControlType::torque;
  m.voltage_limit        = 18.0f;

  m.init();
  m.initFOC();
  m.target = 0.0f;
}

/* -------------------- 9. SETUP ---------------------------------- */
void setup() {
  // OC-ADJ pins (high → normal operation)
  pinMode(drv1.ocAdj, OUTPUT); digitalWrite(drv1.ocAdj, HIGH);
  pinMode(drv2.ocAdj, OUTPUT); digitalWrite(drv2.ocAdj, HIGH);

  Serial.begin(115200);
  Serial.println(F("=== Robot init ==="));

  Wire.begin();
  Wire.setClock(400000);

  // ---- I2C mux presence ----
  Wire.beginTransmission(PCA9548A_ADDR);
  if (Wire.endTransmission() != 0) {
    Serial.println(F("I2C mux NOT found!"));
    while (true) delay(1000);
  }
  Serial.println(F("I2C mux OK"));

  // ---- MPU6050 ----
  if (!mpu.begin()) {
    Serial.println(F("MPU6050 NOT found!"));
    while (true) delay(10);
  }
  mpu.setAccelerometerRange(MPU6050_RANGE_4_G);
  mpu.setGyroRange(MPU6050_RANGE_500_DEG);
  mpu.setFilterBandwidth(MPU6050_BAND_94_HZ);

  // ---- DRV8302 bootstrap ----
  pinMode(drv1.oc, OUTPUT); digitalWrite(drv1.oc, LOW);
  pinMode(drv1.pwm, OUTPUT); digitalWrite(drv1.pwm, HIGH);
  pinMode(drv2.oc, OUTPUT); digitalWrite(drv2.oc, LOW);
  pinMode(drv2.pwm, OUTPUT); digitalWrite(drv2.pwm, HIGH);
  delay(200);

  // ---- Motors ----
  initMotor(motor1, driver1, encoder1, 2);
  initMotor(motor2, driver2, encoder2, 3);

  command.add('M', [](char* cmd) {
    command.motor(&motor1, cmd);
    command.motor(&motor2, cmd);
  }, "motor");

  // ---- Initial Kalman angle ----
  sensors_event_t a, g, temp;
  mpu.getEvent(&a, &g, &temp);
  const float initPitch = atan2f(-a.acceleration.x,
                     sqrtf(a.acceleration.y * a.acceleration.y +
                           a.acceleration.z * a.acceleration.z)) * RAD_TO_DEG;
  kalman.angle = initPitch;

  // ---- Velocity tracking init ----
  selectChannel(2); last_m1_angle = motor1.shaft_angle;
  selectChannel(3); last_m2_angle = motor2.shaft_angle;
  last_vel_time = micros();

  Serial.println(F("Robot ready – NORMAL"));
}

/* -------------------- 10. PITCH (KALMAN) ----------------------- */
float getPitch() {
  sensors_event_t a, g, temp;
  mpu.getEvent(&a, &g, &temp);

  const float accelPitch = atan2f(-a.acceleration.x,
                     sqrtf(a.acceleration.y * a.acceleration.y +
                           a.acceleration.z * a.acceleration.z)) * RAD_TO_DEG;
  const float gyroRate   = g.gyro.y * RAD_TO_DEG;

  static unsigned long last = micros();
  const unsigned long now  = micros();
  const float dt = (now - last) * 1e-6f;
  last = now;

  return kalman.getAngle(accelPitch, gyroRate, dt);
}

/* -------------------- 11. VELOCITY UPDATE ---------------------- */
void updateVelocities() {
  const unsigned long now = micros();
  const float dt = (now - last_vel_time) * 1e-6f;

  if (dt < 0.001f) return;               // at least 1 ms

  selectChannel(2);
  const float m1_angle = motor1.shaft_angle;
  selectChannel(3);
  const float m2_angle = motor2.shaft_angle;

  const float raw1 = (m1_angle - last_m1_angle) / dt;
  const float raw2 = (m2_angle - last_m2_angle) / dt;

  // simple 1st-order LPF
  static float v1_filt = 0.0f, v2_filt = 0.0f;
  v1_filt = 0.7f * v1_filt + 0.3f * raw1;
  v2_filt = 0.7f * v2_filt + 0.3f * raw2;

  motor1_vel = v1_filt;
  motor2_vel = v2_filt;

  last_m1_angle = m1_angle;
  last_m2_angle = m2_angle;
  last_vel_time = now;
}

/* -------------------- 12. BALANCE COMPENSATION ----------------- */
float calcBalanceComp() {
  // Desired: motor1_vel ≈ -motor2_vel  →  sum ≈ 0
  const float vel_error = motor1_vel + motor2_vel;
  const float avg_speed = (abs(motor1_vel) + abs(motor2_vel)) * 0.5f;

  if (avg_speed > 0.5f) {                 // only when moving
    const float p = BALANCE_KP * vel_error;

    vel_error_integral += vel_error * 0.001f;   // ~1 ms loop
    vel_error_integral = constrain(vel_error_integral, -5.0f, 5.0f);
    const float i = BALANCE_KI * vel_error_integral;

    balance_comp = constrain(p + i, -MAX_BALANCE_COMPENSATION,
                                   MAX_BALANCE_COMPENSATION);
  } else {
    vel_error_integral *= 0.95f;          // decay
    balance_comp       *= 0.90f;
  }
  return balance_comp;
}

/* -------------------- 13. SAFE MOTOR DRIVE --------------------- */
void driveMotors(float voltage, float comp) {
  if (robotState == RobotState::NORMAL) {
    motor1.target = -voltage - comp;
    motor2.target =  voltage - comp;
  } else {
    motor1.target = motor2.target = 0.0f;
  }

  // Keep FOC alive
  selectChannel(2);
  motor1.loopFOC();
  motor1.move();

  selectChannel(3);
  motor2.loopFOC();
  motor2.move();
}

/* -------------------- 14. MAIN LOOP ---------------------------- */
void loop() {
  updateVelocities();
  const float pitch = getPitch();
  const float pitch_err = TARGET_PITCH - pitch;

  /* ---------- STATE MACHINE ---------- */
  switch (robotState) {
    case RobotState::NORMAL:
      if (abs(pitch) > FALL_THRESHOLD) {
        robotState = RobotState::FALLEN;
        uprightStartTime = 0;
        Serial.println(F("*** FALL DETECTED – motors stopped ***"));
      } else {
        const float err = (abs(pitch_err) < DEAD_ZONE) ? 0.0f : pitch_err;
        const float voltage = pid_balance(err);
        const float comp = calcBalanceComp();
        driveMotors(voltage, comp);
      }
      break;

    case RobotState::FALLEN:
      driveMotors(0.0f, 0.0f);

      if (pitch >= UPRIGHT_MIN && pitch <= UPRIGHT_MAX) {
        if (uprightStartTime == 0) {
          uprightStartTime = millis();
          Serial.println(F("Upright – hold 5 s…"));
        } else if (millis() - uprightStartTime >= RECOVERY_TIME) {
          robotState = RobotState::NORMAL;
          vel_error_integral = balance_comp = 0.0f;
          Serial.println(F("*** RECOVERED – balancing resumed ***"));
        }
      } else {
        uprightStartTime = 0;
      }
      break;

    case RobotState::RECOVERY:   // unused – kept for completeness
      break;
  }

  /* ---------- COMMAND HANDLER (throttled) ---------- */
  static unsigned long lastCmd = 0;
  if (millis() - lastCmd > 100) {
    command.run();
    lastCmd = millis();
  }

  /* ---------- DEBUG PRINT (500 ms) ---------- */
  static unsigned long lastPrint = 0;
  if (millis() - lastPrint > 500) {
    Serial.print(F("Pitch:")); Serial.print(pitch, 1);
    Serial.print(F("° State:"));
    switch (robotState) {
      case RobotState::NORMAL:  Serial.print(F("NORMAL")); break;
      case RobotState::FALLEN:  Serial.print(F("FALLEN")); break;
      case RobotState::RECOVERY:Serial.print(F("RECOVERY"));break;
    }
    if (robotState == RobotState::FALLEN && uprightStartTime) {
      Serial.print(F(" Hold:"));
      Serial.print((millis() - uprightStartTime) / 1000.0, 1);
      Serial.print('s');
    }
    Serial.print(F(" V1:")); Serial.print(motor1_vel, 2);
    Serial.print(F(" V2:")); Serial.print(motor2_vel, 2);
    Serial.println();
    lastPrint = millis();
  }
}
